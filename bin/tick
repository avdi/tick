#!/usr/bin/env ruby

require 'rubygems'
require 'main'
require 'highline'
require 'highline/import'
require 'git'
require 'nokogiri'
require 'yaml/store'
require 'net/https'
require 'addressable/uri'
require 'forwardable'

module Tick
  class Project
    extend Forwardable
    def_delegator :ticketing_project, :name

    fattr :ticketing_system
    fattr :ticketing_project

    def initialize
      self.ticketing_system  = nil
      self.ticketing_project = NullProject.new
    end
  end

  class NullProject
    fattr :name => 'not set'
  end

  module TrackerResource
    attr_reader :url, :tracker

    fattr('response') {
      fetch(url)
    }

    def initialize(url, tracker)
      @url     = Addressable::URI.parse(url)
      @tracker = tracker
    end

    def [](path)
      xml.xpath(path).text
    end

    def representation
      response.body
    end

    def etag
      response['etag']
    end

    def fetch(url)
      tracker.fetch(url)
    end

    def token
      tracker.token
    end

    def xml
      Nokogiri::XML(representation)
    end
  end

  class Tracker
    fattr :token
    fattr :base_uri

    fattr('client') {
      client = Net::HTTP.new(
        base_uri.host,
        base_uri.inferred_port)
      client.use_ssl     = true if base_uri.scheme == 'https'
      # client.certain        = OpenSSL::X509::Certificate.new(DATA)
      # client.key         = OpenSSL::PKey::RSA.new(DATA)
      client.verify_mode = OpenSSL::SSL::VERIFY_NONE # TODO fix this!
      client
    }

    def initialize(base_uri)
      @base_uri = Addressable::URI.parse(base_uri)
    end

    def projects
      Nokogiri::XML(fetch("#{base_uri}/services/v3/projects").body).
        xpath('//project').map do |proj_xml|

        id = proj_xml.xpath('id').text
        Tick::TrackerProject.new(
          "#{base_uri}/services/v3/projects/#{id}",
          self)
      end
    end

    def fetch(url)
      url = Addressable::URI.parse(url)
      request = Net::HTTP::Get.new(url.path)
      request['X-TrackerToken'] = token
      response = client.request(request)
    end
end

  class TrackerProject
    include TrackerResource

    def name
      self['project/name']
    end
  end
end

Main do

  fattr(:ui) {
    hl = HighLine.new
    hl
  }
  fattr(:project_root) { Pathname(Dir.pwd) }
  fattr(:project_config_path) { project_root + '.tick' }
  fattr(:store) {
    store = YAML::Store.new(project_config_path.to_s)
    store.transaction(false) do |store|
      store['tracker'] ||= {}
    end
    store
  }
  fattr(:login) { ui.ask("Tracker login: "){|q| q.default = guess_login } }
  fattr(:password) {
    ui.ask("Tracker password: ") {|q| q.echo = "*"}
  }
  fattr(:token) {
    store['tracker']['token'] or retrieve_token
  }
  fattr(:tracker_base_uri) {
    params['TICK_TRACKER_BASE_URI'].value
  }
  fattr(:client) {
    info "Opening connection to #{tracker_base_uri}"
    client = Net::HTTP.new(
      tracker_base_uri.host,
      tracker_base_uri.inferred_port)
    client.use_ssl     = true if tracker_base_uri.scheme == 'https'
    # client.cert        = OpenSSL::X509::Certificate.new(DATA)
    # client.key         = OpenSSL::PKey::RSA.new(DATA)
    client.verify_mode = OpenSSL::SSL::VERIFY_NONE # TODO fix this!
    client
  }
  fattr(:projects) {
    request = Net::HTTP::Get.new('/services/v3/projects')
    request['X-TrackerToken'] = token
    response = client.request(request)
    logger.debug "Projects XML:"
    logger.debug response.body
    doc = Nokogiri::XML(response.body)
    doc.xpath('//project')
  }
  fattr(:project_name) {
    store['project_name']
  }
  fattr(:project) {
    store['project'] ||= initialize_project
  }

  option 'config_path' do
    default{ project_config_path }
  end

  option 'debug', 'd' do
    cast :boolean
    default false
    attr
  end

  option 'verbose', 'v' do
    cast :boolean
    default false
    attr
  end

  environment('TICK_TRACKER_BASE_URI') {
    default 'https://www.pivotaltracker.com'
    cast lambda {|uri| Addressable::URI.parse(uri)}
    attr
  }

  def before_run
    if debug
      logger.level = ::Logger::DEBUG
    elsif verbose
      logger.level = ::Logger::INFO
    else
      logger.level = ::Logger::WARN
    end
  end

  mode 'project' do
    mode 'list' do
      def run
        store.transaction do
          projects.each do |p|
            puts p.xpath('name').text
          end
        end
      end
    end

    mode 'select' do
      def run
        store.transaction do
          ui.choose do |menu|
            menu.prompt = "Select a project: "
            project.ticketing_system.projects.each do |ticketing_project|
              menu.choice(ticketing_project.name) do
                project.ticketing_project = ticketing_project
              end
            end
          end
        end
      end
    end
  end

  mode 'info' do
    def run
      show_info
    end
  end

  mode 'login' do
    def run
      show_info
    end
  end

  def run
    help!
  end

  private

  def guess_login
    git_repo = Git.open(Dir.pwd)
    git_repo.config('user.email')
  end

  def retrieve_token
    client.start do |client|
      request = Net::HTTP::Get.new('/services/v3/tokens/active')
      request.basic_auth login, password
      response = client.request(request)
      case response
      when Net::HTTPSuccess
        token = extract_token(response.body)
        store_token!(token)
        token
      else
        raise "Unable to retrieve API token: #{response.body}"
      end
    end
  end

  def extract_token(data)
    doc = Nokogiri::XML(data)
    doc.at_xpath('//guid').content
  end

  def store_token!(token)
    store['tracker']['token'] = token
    say "Token stored"
  end

  def show_info
    store.transaction do
      say "Project: #{project.name || '<not set>'}"
      say "Tracker token:  #{token}"
    end
  end

  def initialize_project
    project = Tick::Project.new
    ticketing_system = Tick::Tracker.new(tracker_base_uri)
    ticketing_system.token = token
    project.ticketing_system = ticketing_system
    project
  end
end
